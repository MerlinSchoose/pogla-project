#version 450

layout (local_size_x = 8, local_size_y = 8) in;

uniform float anim_time;

layout (std430, binding = 1) buffer position_buffer {
    float pos[];
};

layout (std430, binding = 2) buffer normals_buffer {
    float normals[];
};

vec3 refract(vec3 I, vec3 norm, float eta) {
    float cos_init = dot(normalize(I), normalize(norm));
    if (cos_init < 0) {
        eta = 1 / eta;
        cos_init = -cos_init;
    }
    else {
        norm = -norm;
    }

    float k = 1 - eta * eta * (1 - cos_init * cos_init);

    return eta * I + (eta * cos_init - sqrt(k)) * norm;
}

float fresnel(vec3 I, vec3 norm, float eta) {
    float cos_init = dot(normalize(norm), normalize(I));
    float sin_out;
    if (cos_init > 0)
    sin_out = sqrt(max(0., 1 - cos_init * cos_init)) * eta;
    else {
        sin_out = sqrt(max(0., 1 - cos_init * cos_init)) / eta;
        cos_init = -cos_init;
    }

    if (sin_out >= 1) return 1;

    float cos_out = sqrt(max(0., 1 - sin_out * sin_out));
    float Rs = (eta * cos_init - cos_out) / (eta * cos_init + cos_out);
    float Rp = (cos_init - eta * cos_out) / (cos_init + eta * cos_out);
    return (Rs * Rs + Rp * Rp) / 2;
}

float wave_height(float x, float z, float t) {
    float h = 0.0f;
    vec2 p = vec2(x, z);
    vec2 dir = vec2(1.0, 0);
    float speed = 0.5;
    float frequency = 0.1;
    float A = 1.8;
    float angle = 0.0;
    for (int i = 0; i < 13; ++i) {
        dir = vec2(cos(angle), sin(angle));
        h += sin(t * speed + dot(dir, p) * frequency) * A;
        //p += dir * cos(t * speed + dot(dir, p) * frequency) * A * 4;
        speed *= 1.0;
        frequency *= 1.2;
        A *= 0.8;
        angle += 12.0;
    }
    return h;
}

void main() {
    uint index = gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
    vec3 p = vec3(pos[3 * index], pos[3 * index + 1], pos[3 * index + 2]);

    float e = 1e-3;

    float h = wave_height(p.x, p.z, anim_time);
    float h1 = wave_height(p.x + e, p.z, anim_time);
    float h2 = wave_height(p.x, p.z + e, anim_time);

    vec3 p1 = vec3(p.x + e, h1, p.z);
    vec3 p2 = vec3(p.x, h2, p.z + e);
    vec3 n = normalize(cross(p1 - p, p2 - p));

    pos[3 * index + 1] = h;
    normals[3 * index] = n.x;
    normals[3 * index + 1] = n.y;
    normals[3 * index + 2] = n.z;
}
