#version 450

layout( triangles ) in;

layout( points, max_vertices=3) out;

uniform float zNear;
uniform float zFar;

in vec3 newPos[3];
in vec3 oldPos[3];
in vec3 color[3];

out vec3 intensity;
out vec3 pos;

float attenuation = 0.1;
float amplification = 0.12;
float caustic_intensity(vec3 pos) {
    return amplification * exp(-attenuation * -pos.y / 30.f);
}

void main() {
    float zNear = 8.f;
    float zFar = 500.f;
    vec4 p = (gl_in[0].gl_Position + gl_in[1].gl_Position + gl_in[2].gl_Position) / 3.0;
    //float oldArea = length(cross(oldPos[1] - oldPos[0], oldPos[2] - oldPos[0])) / 2.0;
    //float newArea = length(cross(newPos[1] - newPos[0], newPos[2] - newPos[0])) / 2.0;
    float smax = 80.f;
    float smin = 10.f;
    float a = smax - zFar * (smax - smin) / (zFar - zNear);
    float b = zNear * zFar * (smax - smin) / (zFar - zNear);

    float s = a + b / (gl_in[0].gl_Position.z);
    gl_Position = gl_in[0].gl_Position;
    gl_PointSize = s;
    if (color[0].x > 0) {
        intensity = caustic_intensity(newPos[0]).xxx;
        pos = newPos[0];
        EmitVertex();
    }
    s = a + b / (gl_in[1].gl_Position.z);
    gl_Position = gl_in[1].gl_Position;
    gl_PointSize = s;
    if (color[1].x > 0) {
        intensity = caustic_intensity(newPos[1]).xxx;
        pos = newPos[1];
        EmitVertex();
    }


    s = a + b / (gl_in[2].gl_Position.z);
    gl_Position = gl_in[2].gl_Position;
    gl_PointSize = s;
    if (color[2].x > 0) {
        intensity = caustic_intensity(newPos[2]).xxx;
        pos = newPos[2];
        EmitVertex();
    }

    /*
    gl_Position = gl_in[1].gl_Position;
    EmitVertex();
    gl_Position = gl_in[2].gl_Position;
    EmitVertex();
    */
}